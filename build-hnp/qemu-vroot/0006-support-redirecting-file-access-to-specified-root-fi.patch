From f47e1f434eed918333b48fb9db897b68f5e10bbc Mon Sep 17 00:00:00 2001
From: hackeris <hackeris@qq.com>
Date: Sat, 9 Aug 2025 00:28:44 +0800
Subject: [PATCH 6/6] support redirecting file access to specified root
 filesystem

---
 .gitignore             |   2 +-
 include/qemu/path.h    |   5 +-
 linux-user/elfload.c   |   3 +-
 linux-user/execve.c    | 254 ++++++++++++++++++++++++++
 linux-user/execve.h    |  27 +++
 linux-user/main.c      |   2 +
 linux-user/meson.build |   1 +
 linux-user/syscall.c   | 342 +++++++++++++++++++++++++++++------
 util/path.c            | 394 +++++++++++++++++++++++++++++++++++++----
 9 files changed, 941 insertions(+), 89 deletions(-)
 create mode 100644 linux-user/execve.c
 create mode 100644 linux-user/execve.h

diff --git a/.gitignore b/.gitignore
index 68b76b9132e..56de0ded09d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,4 +21,4 @@ GTAGS
 *.depend_raw
 *.swp
 *.patch
-*.gcov
+*.gcov
\ No newline at end of file
diff --git a/include/qemu/path.h b/include/qemu/path.h
index c6292a9709d..5784bb92206 100644
--- a/include/qemu/path.h
+++ b/include/qemu/path.h
@@ -2,6 +2,9 @@
 #define QEMU_PATH_H
 
 void init_paths(const char *prefix);
-const char *path(const char *pathname);
+char *relocate_path_at(int dirfd, const char *name, char *out, bool follow_symlink);
+char *restore_path(const char* name, char* out);
+char* resolve_with_path_env(const char* path_env, int dirfd, const char* name, char* out);
+char* resolve_abs_with_cwd(const char* path, char* out);
 
 #endif
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index c5f742ad9df..78958b2f21b 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -3609,7 +3609,8 @@ static void load_elf_interp(const char *filename, struct image_info *info,
     int fd, retval;
     Error *err = NULL;
 
-    fd = open(path(filename), O_RDONLY);
+    char reloc[PATH_MAX];
+    fd = open(relocate_path_at(AT_FDCWD, filename, reloc, true), O_RDONLY);
     if (fd < 0) {
         error_setg_file_open(&err, errno, filename);
         error_report_err(err);
diff --git a/linux-user/execve.c b/linux-user/execve.c
new file mode 100644
index 00000000000..7f7ca2e0bb3
--- /dev/null
+++ b/linux-user/execve.c
@@ -0,0 +1,254 @@
+#include "execve.h"
+#include "qemu/path.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/limits.h>
+
+static char qemu_abs_path[PATH_MAX];
+
+static const char** argv_prefix;
+static int n_argv_prefix;
+
+void setup_for_execve(const char** argv, int optind)
+{
+    ssize_t ret = readlink("/proc/self/exe", qemu_abs_path, PATH_MAX - 1);
+    assert(ret > 0);
+    qemu_abs_path[ret] = '\0';
+
+    argv_prefix = calloc(optind + 1, sizeof(char*));
+    argv_prefix[0] = qemu_abs_path;
+    for (int i = 1; i < optind; i++) {
+        argv_prefix[i] = argv[i];
+    }
+    argv_prefix[optind] = NULL;
+    n_argv_prefix = optind;
+
+    char** ld_prefix = argv_prefix;
+    while (*ld_prefix != NULL && strcmp(*ld_prefix, "-L") != 0) {
+        ld_prefix++;
+    }
+    if (*ld_prefix != NULL && ld_prefix[1] != NULL) {
+        char* abs_ld_prefix = calloc(PATH_MAX, sizeof(char));
+        ld_prefix[1] = resolve_abs_with_cwd(ld_prefix[1], abs_ld_prefix);
+    }
+}
+
+const char* get_qemu_abs_path(void)
+{
+    return qemu_abs_path;
+}
+
+const char** get_qemu_argv_prefix(void)
+{
+    return argv_prefix;
+}
+
+const char* find_path_env_value(const char** envp)
+{
+    const char** pathenv = envp;
+    while (*pathenv != NULL && strstr(*pathenv, "PATH=") != *pathenv) {
+        pathenv += 1;
+    }
+    if (*pathenv != NULL) {
+        return *pathenv + 5;
+    }
+    else {
+        return NULL;
+    }
+}
+
+const char* resolve_program_path(int dirfd, const char* p, const char** envp, char* out, int flags)
+{
+    //	TODO: support AT_EMPTY_PATH in flags
+
+    if (p[0] != '/' && p[0] != '.') {
+        const char* path_value = find_path_env_value(envp);
+        if (path_value != NULL) {
+            char prog[PATH_MAX] = {0};
+            if (resolve_with_path_env(path_value, dirfd, p, prog)) {
+                return relocate_path_at(dirfd, prog, out, !(flags & AT_SYMLINK_NOFOLLOW));
+            }
+        }
+    }
+
+    return relocate_path_at(dirfd, p, out, !(flags & AT_SYMLINK_NOFOLLOW));
+}
+
+int size_of_vp(const char** vp)
+{
+    int c = 0;
+    while (vp[c] != NULL) { c++; };
+    return c;
+}
+
+bool is_elf(const char* buff)
+{
+    return buff[0] == 0x7f && buff[1] == 0x45 && buff[2] == 0x4c && buff[3] == 0x46;
+}
+
+bool is_shebang(const char* buff)
+{
+    return buff[0] == '#' && buff[1] == '!';
+}
+
+/**
+ * copied and modified from proot
+ */
+int extract_shebang(const char* host_path,
+                    char user_path[PATH_MAX], char argument[BINPRM_BUF_SIZE])
+{
+    char tmp2[2];
+    char tmp;
+
+    size_t current_length;
+    size_t i;
+
+    int status;
+    int fd;
+
+    /* Assumption.  */
+    assert(BINPRM_BUF_SIZE < PATH_MAX);
+
+    argument[0] = '\0';
+
+    /* Inspect the executable.  */
+    fd = open(host_path, O_RDONLY);
+    if (fd < 0)
+        return -errno;
+
+    status = read(fd, tmp2, 2 * sizeof(char));
+    if (status < 0) {
+        status = -errno;
+        goto end;
+    }
+    if ((size_t)status < 2 * sizeof(char)) {
+        /* EOF */
+        status = 0;
+        goto end;
+    }
+
+    /* Check if it really is a script text. */
+    if (tmp2[0] != '#' || tmp2[1] != '!') {
+        status = 0;
+        goto end;
+    }
+    current_length = 2;
+    user_path[0] = '\0';
+
+    /* Skip leading spaces. */
+    do {
+        status = read(fd, &tmp, sizeof(char));
+        if (status < 0) {
+            status = -errno;
+            goto end;
+        }
+        if ((size_t)status < sizeof(char)) {
+            /* EOF */
+            status = -ENOEXEC;
+            goto end;
+        }
+
+        current_length++;
+    }
+    while ((tmp == ' ' || tmp == '\t') && current_length < BINPRM_BUF_SIZE);
+
+    /* Slurp the interpreter path until the first space or end-of-line. */
+    for (i = 0; current_length < BINPRM_BUF_SIZE; current_length++, i++) {
+        switch (tmp) {
+        case ' ':
+        case '\t':
+            /* Remove spaces in between the interpreter
+             * and the hypothetical argument. */
+            user_path[i] = '\0';
+            break;
+
+        case '\n':
+        case '\r':
+            /* There is no argument. */
+            user_path[i] = '\0';
+            argument[0] = '\0';
+            status = 1;
+            goto end;
+
+        default:
+            /* There is an argument if the previous
+             * character in user_path[] is '\0'. */
+            if (i > 1 && user_path[i - 1] == '\0')
+                goto argument;
+            else
+                user_path[i] = tmp;
+            break;
+        }
+
+        status = read(fd, &tmp, sizeof(char));
+        if (status < 0) {
+            status = -errno;
+            goto end;
+        }
+        if ((size_t)status < sizeof(char)) {
+            /* EOF */
+            user_path[i] = '\0';
+            argument[0] = '\0';
+            status = 1;
+            goto end;
+        }
+    }
+
+    /* The interpreter path is too long, truncate it. */
+    user_path[i] = '\0';
+    argument[0] = '\0';
+    status = 1;
+    goto end;
+
+argument:
+
+    /* Slurp the argument until the end-of-line. */
+    for (i = 0; current_length < BINPRM_BUF_SIZE; current_length++, i++) {
+        switch (tmp) {
+        case '\n':
+        case '\r':
+            argument[i] = '\0';
+
+            /* Remove trailing spaces. */
+            for (i--; i > 0 && (argument[i] == ' ' || argument[i] == '\t'); i--)
+                argument[i] = '\0';
+
+            status = 1;
+            goto end;
+
+        default:
+            argument[i] = tmp;
+            break;
+        }
+
+        status = read(fd, &tmp, sizeof(char));
+        if (status < 0) {
+            status = -errno;
+            goto end;
+        }
+        if ((size_t)status < sizeof(char)) {
+            /* EOF */
+            argument[0] = '\0';
+            status = 1;
+            goto end;
+        }
+    }
+
+    /* The argument is too long, truncate it. */
+    argument[i] = '\0';
+    status = 1;
+
+end:
+    close(fd);
+
+    /* Did an error occur or isn't a script? */
+    if (status <= 0)
+        return status;
+
+    return 1;
+}
diff --git a/linux-user/execve.h b/linux-user/execve.h
new file mode 100644
index 00000000000..ca18c6b8c22
--- /dev/null
+++ b/linux-user/execve.h
@@ -0,0 +1,27 @@
+#ifndef _EXECVE_H
+#define _EXECVE_H
+#include <stdbool.h>
+#include <linux/limits.h>
+
+#define BINPRM_BUF_SIZE 256
+
+void setup_for_execve(const char** argv, int optind);
+
+const char* get_qemu_abs_path(void);
+const char** get_qemu_argv_prefix(void);
+
+//  find value of PATH env variable in envp
+const char *find_path_env_value(const char **envp);
+
+const char *resolve_program_path(int dirfd, const char *p, const char **envp, char* out, int flags);
+
+int size_of_vp(const char** vp);
+
+bool is_elf(const char *buff);
+
+bool is_shebang(const char *buff);
+
+int extract_shebang(const char *host_path,
+        char user_path[PATH_MAX], char argument[BINPRM_BUF_SIZE]);
+
+#endif
diff --git a/linux-user/main.c b/linux-user/main.c
index 3f8335d6c8e..04235e2b7d0 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -51,6 +51,7 @@
 #include "trace/control.h"
 #include "target_elf.h"
 #include "user/cpu_loop.h"
+#include "execve.h"
 #include "crypto/init.h"
 #include "fd-trans.h"
 #include "signal-common.h"
@@ -752,6 +753,7 @@ int main(int argc, char **argv, char **envp)
     qemu_plugin_add_opts();
 
     optind = parse_args(argc, argv);
+    setup_for_execve(argv, optind);
 
     qemu_set_log_filename_flags(last_log_filename,
                                 last_log_mask | (enable_strace * LOG_STRACE),
diff --git a/linux-user/meson.build b/linux-user/meson.build
index efca8433698..6eef48f1c42 100644
--- a/linux-user/meson.build
+++ b/linux-user/meson.build
@@ -17,6 +17,7 @@ linux_user_ss.add(files(
   'signal.c',
   'strace.c',
   'syscall.c',
+  'execve.c',
   'thunk.c',
   'uaccess.c',
   'uname.c',
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 48a532c52e1..93212666364 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -103,6 +103,7 @@
 #include <linux/mtio.h>
 #include <linux/fs.h>
 #include <linux/fd.h>
+#include <linux/openat2.h>
 #if defined(CONFIG_FIEMAP)
 #include <linux/fiemap.h>
 #endif
@@ -129,6 +130,7 @@
 #include <libdrm/drm.h>
 #include <libdrm/i915_drm.h>
 #endif
+#include "execve.h"
 #include "linux_loop.h"
 #include "uname.h"
 
@@ -2093,6 +2095,17 @@ static inline abi_long host_to_target_cmsg(struct target_msghdr *target_msgh,
     return 0;
 }
 
+static int do_getcwd(char *buf, size_t size) {
+
+    if (sys_getcwd1(buf, size) == NULL) {
+        /* getcwd() sets errno */
+        return (-1);
+    }
+    char res[PATH_MAX];
+    restore_path(buf, res);
+    return strlen(res) + 1;
+}
+
 /* do_setsockopt() Must return target values and target errnos. */
 static abi_long do_setsockopt(int sockfd, int level, int optname,
                               abi_ulong optval_addr, socklen_t optlen)
@@ -6761,6 +6774,26 @@ static int do_fork(CPUArchState *env, unsigned int flags, abi_ulong newsp,
     return ret;
 }
 
+static int do_mount(const char *source, const char *target,
+                 const char *filesystemtype, unsigned long mountflags,
+                 const void * data)
+{
+    if (strcmp(filesystemtype, "proc") == 0) {
+        return -EPERM;
+    }
+
+    return mount(source, target, filesystemtype, mountflags, data);
+}
+
+static int do_umount2(const char *target, int flags)
+{
+    if (strstr(target, "/proc") != NULL) {
+        return -EPERM;
+    }
+
+    return umount2(target, flags);
+}
+
 /* warning : doesn't handle linux specific flags... */
 static int target_to_host_fcntl_cmd(int cmd)
 {
@@ -7911,7 +7944,8 @@ static abi_long do_name_to_handle_at(abi_long dirfd, abi_long pathname,
     fh = g_malloc0(total_size);
     fh->handle_bytes = size;
 
-    ret = get_errno(name_to_handle_at(dirfd, path(name), fh, &mid, flags));
+    char reloc[PATH_MAX];
+    ret = get_errno(name_to_handle_at(dirfd, relocate_path_at(dirfd, name, reloc, true), fh, &mid, flags));
     unlock_user(name, pathname, 0);
 
     /* man name_to_handle_at(2):
@@ -8508,10 +8542,13 @@ int do_guest_openat(CPUArchState *cpu_env, int dirfd, const char *pathname,
         return fd;
     }
 
+    char reloc[PATH_MAX];
+    relocate_path_at(dirfd, pathname, reloc, true);
+
     if (safe) {
-        return safe_openat(dirfd, path(pathname), flags, mode);
+        return safe_openat(dirfd, reloc, flags, mode);
     } else {
-        return openat(dirfd, path(pathname), flags, mode);
+        return openat(dirfd, reloc, flags, mode);
     }
 }
 
@@ -8549,6 +8586,9 @@ static int do_openat2(CPUArchState *cpu_env, abi_long dirfd,
     if (fd > -2) {
         ret = get_errno(fd);
     } else {
+        char reloc[PATH_MAX];
+        //  TODO: support how.resolve
+        relocate_path_at(dirfd, pathname, reloc, true);
         ret = get_errno(safe_openat2(dirfd, pathname, &how,
                                      sizeof(struct open_how_ver0)));
     }
@@ -8574,20 +8614,128 @@ ssize_t do_guest_readlink(const char *pathname, char *buf, size_t bufsiz)
     }
 
     if (is_proc_myself((const char *)pathname, "exe")) {
+        char user[PATH_MAX];
+        restore_path(exec_path, user);
         /*
          * Don't worry about sign mismatch as earlier mapping
          * logic would have thrown a bad address error.
          */
-        ret = MIN(strlen(exec_path), bufsiz);
+        ret = MIN(strlen(user), bufsiz);
         /* We cannot NUL terminate the string. */
-        memcpy(buf, exec_path, ret);
+        memcpy(buf, user, ret);
     } else {
-        ret = readlink(path(pathname), buf, bufsiz);
+        char reloc[PATH_MAX];
+        ret = get_errno(readlink(relocate_path_at(AT_FDCWD, pathname, reloc, false), buf, bufsiz));
     }
 
     return ret;
 }
 
+static int execve_elf(const char *program, const char **argv, const char* const *envp)
+{
+    const char* qemu = get_qemu_abs_path();
+
+    int original_argc = size_of_vp(argv);
+
+    const char** argv_prefix = get_qemu_argv_prefix();
+    int n_prefix = size_of_vp(argv_prefix);
+
+    const char **new_argv = g_new0(char *, n_prefix + 2 + original_argc + 1);
+    memcpy(new_argv, argv_prefix, n_prefix * sizeof(char *));
+    new_argv[n_prefix + 0] = "-0";
+    new_argv[n_prefix + 1] = argv[0];
+    memcpy(&new_argv[n_prefix + 2], argv, (original_argc + 1) * sizeof(char *));
+
+    int idx_guest_program = n_prefix + 2;
+    new_argv[idx_guest_program] = program;
+
+    int ret = safe_execve(qemu, new_argv, envp);
+
+    g_free(new_argv);
+
+    return ret;
+}
+
+int execve_shebang(const char *filepath, const char **argv, const char* const *envp)
+{
+    char user_path[PATH_MAX] = {0};
+    char argument[BINPRM_BUF_SIZE] = {0};
+    char program_abs[PATH_MAX];
+
+    if (extract_shebang(filepath, user_path, argument) < 0) {
+        errno = ENOEXEC;
+        return -1;
+    }
+
+    relocate_path_at(AT_FDCWD, user_path, program_abs, true);
+
+    const char* qemu = get_qemu_abs_path();
+
+    int original_argc = size_of_vp(argv);
+
+    const char** argv_prefix = get_qemu_argv_prefix();
+    int n_prefix = size_of_vp(argv_prefix);
+
+    const char **new_argv;
+    if (argument[0] != '\0') {
+
+        new_argv = g_new0(char *, n_prefix + 2 + 2 + original_argc + 1);
+
+        memcpy(new_argv, argv_prefix, n_prefix * sizeof(char*));
+
+        new_argv[n_prefix + 0] = "-0";
+        new_argv[n_prefix + 1] = user_path;
+
+        new_argv[n_prefix + 2] = program_abs;
+        new_argv[n_prefix + 3] = argument;
+        new_argv[n_prefix + 4] = filepath;
+
+        memcpy(&new_argv[n_prefix + 5], argv + 1, original_argc * sizeof(char *));
+
+    } else {
+
+        new_argv = g_new0(char *, n_prefix + 2 + 1 + original_argc + 1);
+
+        memcpy(new_argv, argv_prefix, n_prefix * sizeof(char*));
+
+        new_argv[n_prefix + 0] = "-0";
+        new_argv[n_prefix + 1] = user_path;
+
+        new_argv[n_prefix + 2] = program_abs;
+        new_argv[n_prefix + 3] = filepath;
+
+        memcpy(&new_argv[n_prefix + 4], argv + 1, original_argc * sizeof(char *));
+    }
+
+    int ret = safe_execve(qemu, new_argv, envp);
+
+    g_free(new_argv);
+
+    return ret;
+}
+
+static int do_execve_with_reloc(const char *p, const char **argp, const char* const *envp)
+{
+    int prog_fd = open(p, O_RDONLY);
+    if (prog_fd < 0) {
+        return -1;
+    }
+    char buff[4];
+    if (read(prog_fd, buff, 4) < 4) {
+        errno = ENOEXEC;
+        return -1;
+    }
+
+    if (is_elf(buff)) {
+        return execve_elf(p, argp, envp);
+    } else if (is_shebang(buff)) {
+        return execve_shebang(p, argp, envp);
+    } else {
+        errno = ENOEXEC;
+        return -1;
+    }
+}
+
 static int do_execv(CPUArchState *cpu_env, int dirfd,
                     abi_long pathname, abi_long guest_argp,
                     abi_long guest_envp, int flags, bool is_execveat)
@@ -8673,9 +8821,16 @@ static int do_execv(CPUArchState *cpu_env, int dirfd,
     if (is_proc_myself(p, "exe")) {
         exe = exec_path;
     }
-    ret = is_execveat
-        ? safe_execveat(dirfd, exe, argp, envp, flags)
-        : safe_execve(exe, argp, envp);
+    if (is_execveat) {
+        //  TODO: support flags
+        char new_program_path[PATH_MAX];
+        resolve_program_path(dirfd, p, envp, new_program_path, flags);
+        ret = safe_execveat(dirfd, new_program_path, argp, envp, flags);
+    } else {
+        char new_program_path[PATH_MAX];
+        resolve_program_path(AT_FDCWD, p, envp, new_program_path, 0);
+        ret = do_execve_with_reloc(new_program_path, argp, envp);
+    }
     ret = get_errno(ret);
 
     unlock_user(p, pathname, 0);
@@ -9237,6 +9392,9 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
 #endif
     void *p;
 
+    char reloc[PATH_MAX];
+    char reloc2[PATH_MAX];
+
     switch(num) {
     case TARGET_NR_exit:
         /* In old applications this may be used to implement _exit(2).
@@ -9452,7 +9610,8 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!p || !p2)
                 ret = -TARGET_EFAULT;
             else
-                ret = get_errno(link(p, p2));
+                ret = get_errno(link(relocate_path_at(AT_FDCWD, p, reloc, false),
+                    relocate_path_at(AT_FDCWD, p2, reloc2, false)));
             unlock_user(p2, arg2, 0);
             unlock_user(p, arg1, 0);
         }
@@ -9468,8 +9627,37 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             p2 = lock_user_string(arg4);
             if (!p || !p2)
                 ret = -TARGET_EFAULT;
-            else
-                ret = get_errno(linkat(arg1, p, arg3, p2, arg5));
+            else {
+                relocate_path_at(arg1, p, reloc, false);
+                relocate_path_at(arg3, p2, reloc2, false);
+                ret = get_errno(linkat(arg1, reloc, arg3, reloc2, arg5));
+                if (ret < 0 && errno == EACCES) {
+                    //  replace linkat by copy
+                    int from_fd = openat(arg1, reloc, O_RDONLY | O_LARGEFILE);
+                    if (from_fd < 0) {
+                        goto linkat_end;
+                    }
+
+                    struct stat s;
+                    if (fstat(from_fd, &s) < 0 || !S_ISREG(s.st_mode)) {
+                        errno = ENOENT;
+                        goto linkat_end;
+                    }
+                    int to_fd = creat(reloc2, s.st_mode);
+                    if (to_fd < 0) {
+                        goto linkat_end;
+                    }
+
+                    char buf[4096];
+                    int rd;
+                    while ((rd = read(from_fd, buf, sizeof(buf))) > 0) {
+                        write(to_fd, buf, rd);
+                    }
+                    ret = 0;
+                    errno = 0;
+                }
+            }
+        linkat_end:
             unlock_user(p, arg2, 0);
             unlock_user(p2, arg4, 0);
         }
@@ -9479,7 +9667,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_unlink:
         if (!(p = lock_user_string(arg1)))
             return -TARGET_EFAULT;
-        ret = get_errno(unlink(p));
+        ret = get_errno(unlink(relocate_path_at(AT_FDCWD, p, reloc, false)));
         unlock_user(p, arg1, 0);
         return ret;
 #endif
@@ -9487,7 +9675,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_unlinkat:
         if (!(p = lock_user_string(arg2)))
             return -TARGET_EFAULT;
-        ret = get_errno(unlinkat(arg1, p, arg3));
+        ret = get_errno(unlinkat(arg1, relocate_path_at(arg1, p, reloc, false), arg3));
         unlock_user(p, arg2, 0);
         return ret;
 #endif
@@ -9498,7 +9686,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_chdir:
         if (!(p = lock_user_string(arg1)))
             return -TARGET_EFAULT;
-        ret = get_errno(chdir(p));
+        ret = get_errno(chdir(relocate_path_at(AT_FDCWD, p, reloc, true)));
         unlock_user(p, arg1, 0);
         return ret;
 #ifdef TARGET_NR_time
@@ -9591,9 +9779,9 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
              * string.
              */
             if (!arg5) {
-                ret = mount(p, p2, p3, (unsigned long)arg4, NULL);
+                ret = do_mount(p, p2, p3, (unsigned long)arg4, NULL);
             } else {
-                ret = mount(p, p2, p3, (unsigned long)arg4, g2h(cpu, arg5));
+                ret = do_mount(p, p2, p3, (unsigned long)arg4, g2h(cpu, arg5));
             }
             ret = get_errno(ret);
 
@@ -9753,7 +9941,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!(p = lock_user_string(arg2))) {
                 return -TARGET_EFAULT;
             }
-            ret = get_errno(futimesat(arg1, path(p), tvp));
+            ret = get_errno(futimesat(arg1, relocate_path_at(arg1, p, reloc, true), tvp));
             unlock_user(p, arg2, 0);
         }
         return ret;
@@ -9763,7 +9951,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(access(path(p), arg2));
+        ret = get_errno(access(relocate_path_at(AT_FDCWD, p, reloc, true), arg2));
         unlock_user(p, arg1, 0);
         return ret;
 #endif
@@ -9772,7 +9960,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg2))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(faccessat(arg1, p, arg3, 0));
+        ret = get_errno(faccessat(arg1, relocate_path_at(arg1, p, reloc, true), arg3, 0));
         unlock_user(p, arg2, 0);
         return ret;
 #endif
@@ -9807,7 +9995,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!p || !p2)
                 ret = -TARGET_EFAULT;
             else
-                ret = get_errno(rename(p, p2));
+                ret = get_errno(rename(relocate_path_at(AT_FDCWD, p, reloc, false), relocate_path_at(AT_FDCWD, p2, reloc2, false)));
             unlock_user(p2, arg2, 0);
             unlock_user(p, arg1, 0);
         }
@@ -9821,8 +10009,35 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             p2 = lock_user_string(arg4);
             if (!p || !p2)
                 ret = -TARGET_EFAULT;
-            else
-                ret = get_errno(renameat(arg1, p, arg3, p2));
+            else {
+                relocate_path_at(arg1, p, reloc, false);
+                relocate_path_at(arg3, p2, reloc2, false);
+                ret = get_errno(renameat(arg1, reloc, arg3, reloc2));
+                if (ret < 0 && errno == EACCES) {
+                    struct stat s;
+                    if (lstat(reloc, &s) < 0) {
+                        goto renameat_end;
+                    }
+                    if (!S_ISLNK(s.st_mode)) {
+                        goto renameat_end;
+                    }
+                    char link[PATH_MAX];
+                    ssize_t sz = readlinkat(arg1, reloc, link, PATH_MAX - 1);
+                    if (sz < 0) {
+                        goto renameat_end;
+                    }
+                    link[sz] = '\0';
+                    if (symlinkat(link, arg3, reloc2) < 0) {
+                        goto renameat_end;
+                    }
+                    if (unlinkat(arg1, reloc, 0) < 0) {
+                        goto renameat_end;
+                    }
+                    ret = 0;
+                    errno = 0;
+                }
+            }
+        renameat_end:
             unlock_user(p2, arg4, 0);
             unlock_user(p, arg2, 0);
         }
@@ -9837,7 +10052,10 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!p || !p2) {
                 ret = -TARGET_EFAULT;
             } else {
-                ret = get_errno(sys_renameat2(arg1, p, arg3, p2, arg5));
+                ret = get_errno(sys_renameat2(
+                    arg1, relocate_path_at(arg1, p, reloc, false),
+                    arg3, relocate_path_at(arg3, p2, reloc2, false),
+                    arg5));
             }
             unlock_user(p2, arg4, 0);
             unlock_user(p, arg2, 0);
@@ -9856,7 +10074,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_mkdirat:
         if (!(p = lock_user_string(arg2)))
             return -TARGET_EFAULT;
-        ret = get_errno(mkdirat(arg1, p, arg3));
+        ret = get_errno(mkdirat(arg1, relocate_path_at(arg1, p, reloc, false), arg3));
         unlock_user(p, arg2, 0);
         return ret;
 #endif
@@ -9864,7 +10082,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_rmdir:
         if (!(p = lock_user_string(arg1)))
             return -TARGET_EFAULT;
-        ret = get_errno(rmdir(p));
+        ret = get_errno(rmdir(relocate_path_at(AT_FDCWD, p, reloc, false)));
         unlock_user(p, arg1, 0);
         return ret;
 #endif
@@ -9908,7 +10126,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!(p = lock_user_string(arg1))) {
                 return -TARGET_EFAULT;
             }
-            ret = get_errno(acct(path(p)));
+            ret = get_errno(acct(relocate_path_at(AT_FDCWD, p, reloc, true)));
             unlock_user(p, arg1, 0);
         }
         return ret;
@@ -9916,7 +10134,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_umount2:
         if (!(p = lock_user_string(arg1)))
             return -TARGET_EFAULT;
-        ret = get_errno(umount2(p, arg2));
+        ret = get_errno(do_umount2(p, arg2));
         unlock_user(p, arg1, 0);
         return ret;
 #endif
@@ -10538,7 +10756,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!p || !p2)
                 ret = -TARGET_EFAULT;
             else
-                ret = get_errno(symlink(p, p2));
+                ret = get_errno(symlink(p, relocate_path_at(AT_FDCWD, p2, reloc, false)));
             unlock_user(p2, arg2, 0);
             unlock_user(p, arg1, 0);
         }
@@ -10553,7 +10771,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             if (!p || !p2)
                 ret = -TARGET_EFAULT;
             else
-                ret = get_errno(symlinkat(p, arg2, p2));
+                ret = get_errno(symlinkat(p, arg2, relocate_path_at(arg2, p2, reloc, false)));
             unlock_user(p2, arg3, 0);
             unlock_user(p, arg1, 0);
         }
@@ -10583,15 +10801,17 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
                 /* Short circuit this for the magic exe check. */
                 ret = -TARGET_EINVAL;
             } else if (is_proc_myself((const char *)p, "exe")) {
+                char user[PATH_MAX];
+                restore_path(exec_path, user);
                 /*
                  * Don't worry about sign mismatch as earlier mapping
                  * logic would have thrown a bad address error.
                  */
-                ret = MIN(strlen(exec_path), arg4);
+                ret = MIN(strlen(user), arg4);
                 /* We cannot NUL terminate the string. */
-                memcpy(p2, exec_path, ret);
+                memcpy(p2, user, ret);
             } else {
-                ret = get_errno(readlinkat(arg1, path(p), p2, arg4));
+                ret = get_errno(readlinkat(arg1, relocate_path_at(arg1, p, reloc, false), p2, arg4));
             }
             unlock_user(p2, arg3, ret);
             unlock_user(p, arg2, 0);
@@ -10698,7 +10918,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_truncate:
         if (!(p = lock_user_string(arg1)))
             return -TARGET_EFAULT;
-        ret = get_errno(truncate(p, arg2));
+        ret = get_errno(truncate(relocate_path_at(AT_FDCWD, p, reloc, true), arg2));
         unlock_user(p, arg1, 0);
         return ret;
 #endif
@@ -10712,7 +10932,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_fchmodat:
         if (!(p = lock_user_string(arg2)))
             return -TARGET_EFAULT;
-        ret = get_errno(fchmodat(arg1, p, arg3, 0));
+        ret = get_errno(fchmodat(arg1, relocate_path_at(arg1, p, reloc, true), arg3, 0));
         unlock_user(p, arg2, 0);
         return ret;
 #endif
@@ -10748,7 +10968,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(statfs(path(p), &stfs));
+        ret = get_errno(statfs(relocate_path_at(AT_FDCWD, p, reloc, true), &stfs));
         unlock_user(p, arg1, 0);
     convert_statfs:
         if (!is_error(ret)) {
@@ -10787,7 +11007,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(statfs(path(p), &stfs));
+        ret = get_errno(statfs(relocate_path_at(AT_FDCWD, p, reloc, true), &stfs));
         unlock_user(p, arg1, 0);
     convert_statfs64:
         if (!is_error(ret)) {
@@ -10994,7 +11214,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(stat(path(p), &st));
+        ret = get_errno(stat(relocate_path_at(AT_FDCWD, p, reloc, true), &st));
         unlock_user(p, arg1, 0);
         goto do_stat;
 #endif
@@ -11003,7 +11223,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(lstat(path(p), &st));
+        ret = get_errno(lstat(relocate_path_at(AT_FDCWD, p, reloc, false), &st));
         unlock_user(p, arg1, 0);
         goto do_stat;
 #endif
@@ -11697,7 +11917,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_getcwd:
         if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))
             return -TARGET_EFAULT;
-        ret = get_errno(sys_getcwd1(p, arg2));
+        ret = get_errno(do_getcwd(p, arg2));
         unlock_user(p, arg1, ret);
         return ret;
     case TARGET_NR_capget:
@@ -11859,7 +12079,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(stat(path(p), &st));
+        ret = get_errno(stat(relocate_path_at(AT_FDCWD, p, reloc, true), &st));
         unlock_user(p, arg1, 0);
         if (!is_error(ret))
             ret = host_to_target_stat64(cpu_env, arg2, &st);
@@ -11870,7 +12090,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg1))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(lstat(path(p), &st));
+        ret = get_errno(lstat(relocate_path_at(AT_FDCWD, p, reloc, true), &st));
         unlock_user(p, arg1, 0);
         if (!is_error(ret))
             ret = host_to_target_stat64(cpu_env, arg2, &st);
@@ -11893,7 +12113,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         if (!(p = lock_user_string(arg2))) {
             return -TARGET_EFAULT;
         }
-        ret = get_errno(fstatat(arg1, path(p), &st, arg4));
+        ret = get_errno(fstatat(arg1, relocate_path_at(arg1, p, reloc, !(arg4 & AT_SYMLINK_NOFOLLOW)), &st, arg4));
         unlock_user(p, arg2, 0);
         if (!is_error(ret))
             ret = host_to_target_stat64(cpu_env, arg3, &st);
@@ -11918,7 +12138,9 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
                 struct target_statx host_stx;
                 int mask = arg4;
 
-                ret = get_errno(sys_statx(dirfd, p, flags, mask, &host_stx));
+                ret = get_errno(sys_statx(
+                    dirfd, relocate_path_at(dirfd, p, reloc, !(flags & AT_SYMLINK_NOFOLLOW)),
+                    flags, mask, &host_stx));
                 if (!is_error(ret)) {
                     if (host_to_target_statx(&host_stx, arg5) != 0) {
                         unlock_user(p, arg2, 0);
@@ -11932,7 +12154,9 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
                 }
             }
 #endif
-            ret = get_errno(fstatat(dirfd, path(p), &st, flags));
+            ret = get_errno(fstatat(
+                dirfd, relocate_path_at(dirfd, p, reloc, !(flags & AT_SYMLINK_NOFOLLOW)),
+                &st, flags));
             unlock_user(p, arg2, 0);
 
             if (!is_error(ret)) {
@@ -12053,8 +12277,8 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
     case TARGET_NR_fchownat:
         if (!(p = lock_user_string(arg2))) 
             return -TARGET_EFAULT;
-        ret = get_errno(fchownat(arg1, p, low2highuid(arg3),
-                                 low2highgid(arg4), arg5));
+        ret = get_errno(fchownat(arg1, relocate_path_at(arg1, p, reloc, true), low2highuid(arg3),
+                                     low2highgid(arg4), arg5));
         unlock_user(p, arg2, 0);
         return ret;
 #endif
@@ -12107,19 +12331,27 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
         return ret;
 #endif
     case TARGET_NR_setuid:
-        return get_errno(sys_setuid(low2highuid(arg1)));
+        // we cannot use setuid on OHOS
+        // return get_errno(sys_setuid(low2highuid(arg1)));
+        return 0;
     case TARGET_NR_setgid:
-        return get_errno(sys_setgid(low2highgid(arg1)));
+        // we cannot use setgid on OHOS
+        // return get_errno(sys_setgid(low2highgid(arg1)));
+        return 0;
     case TARGET_NR_setfsuid:
-        return get_errno(setfsuid(arg1));
+        // we cannot use on OHOS
+        // return get_errno(setfsuid(arg1));
+        return 0;
     case TARGET_NR_setfsgid:
-        return get_errno(setfsgid(arg1));
+        // we cannot use on OHOS
+        // return get_errno(setfsgid(arg1));
+        return 0;
 
 #ifdef TARGET_NR_lchown32
     case TARGET_NR_lchown32:
         if (!(p = lock_user_string(arg1)))
             return -TARGET_EFAULT;
-        ret = get_errno(lchown(p, arg2, arg3));
+        ret = get_errno(lchown(relocate_path_at(AT_FDCWD, p, reloc, false), arg2, arg3));
         unlock_user(p, arg1, 0);
         return ret;
 #endif
@@ -12982,7 +13214,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
                 if (!(p = lock_user_string(arg2))) {
                     return -TARGET_EFAULT;
                 }
-                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));
+                ret = get_errno(sys_utimensat(arg1, relocate_path_at(arg1, p, reloc, true), tsp, arg4));
                 unlock_user(p, arg2, 0);
             }
         }
@@ -13011,7 +13243,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
                 if (!p) {
                     return -TARGET_EFAULT;
                 }
-                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));
+                ret = get_errno(sys_utimensat(arg1, relocate_path_at(arg1, p, reloc, true), tsp, arg4));
                 unlock_user(p, arg2, 0);
             }
         }
@@ -13046,7 +13278,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
 #if defined(TARGET_NR_inotify_add_watch)
     case TARGET_NR_inotify_add_watch:
         p = lock_user_string(arg2);
-        ret = get_errno(inotify_add_watch(arg1, path(p), arg3));
+        ret = get_errno(inotify_add_watch(arg1, relocate_path_at(arg1, p, reloc, true), arg3));
         unlock_user(p, arg2, 0);
         return ret;
 #endif
diff --git a/util/path.c b/util/path.c
index 8e174eb4364..f602d351072 100644
--- a/util/path.c
+++ b/util/path.c
@@ -10,61 +10,393 @@
 #include "qemu/path.h"
 #include "qemu/thread.h"
 
-static const char *base;
-static GHashTable *hash;
+#define SYMLOOP_MAX 40
+
+static const char* base;
+static GHashTable* hash;
 static QemuMutex lock;
 
-void init_paths(const char *prefix)
+void init_paths(const char* prefix)
 {
     if (prefix[0] == '\0' || !strcmp(prefix, "/")) {
         return;
     }
 
+    char* tmp_base;
     if (prefix[0] == '/') {
-        base = g_strdup(prefix);
-    } else {
-        char *cwd = g_get_current_dir();
-        base = g_build_filename(cwd, prefix, NULL);
+        tmp_base = g_strdup(prefix);
+    }
+    else {
+        char* cwd = g_get_current_dir();
+        tmp_base = g_build_filename(cwd, prefix, NULL);
         g_free(cwd);
     }
+    char real[PATH_MAX];
+    realpath(tmp_base, real);
+    g_free(tmp_base);
+    base = g_strdup(real);
 
     hash = g_hash_table_new(g_str_hash, g_str_equal);
     qemu_mutex_init(&lock);
 }
 
-/* Look for path in emulation dir, otherwise return name. */
-const char *path(const char *name)
+static bool skip_relocation(const char* name)
+{
+    return strstr(name, "/proc/") == name
+        || strcmp(name, "/proc") == 0
+        || strstr(name, "/sys/") == name
+        || strcmp(name, "/sys") == 0
+        || strcmp(name, "/etc/resolv.conf") == 0
+        || strcmp(name, "/etc/passwd") == 0
+        || strcmp(name, "/dev/null") == 0;
+}
+
+const char* do_relocate_path(const char* name, char* out)
+{
+    if (!base || !name) {
+        //  invalid
+        goto use_original;
+    }
+    if (skip_relocation(name)) {
+        //  reuse hosts
+        goto use_original;
+    }
+    if (strstr(name, base) == name) {
+        //  already at rootfs
+        goto use_original;
+    }
+
+    char abspath[PATH_MAX];
+    if (name[0] != '/') {
+        //  relative to absolute
+        getcwd(abspath, sizeof(abspath));
+        strcat(abspath, "/");
+        strcat(abspath, name);
+    }
+    else {
+        //  absolute
+        strcpy(abspath, base);
+        strcat(abspath, "/");
+        strcat(abspath, name);
+    }
+
+    strcpy(out, abspath);
+    return out;
+
+use_original:
+    strcpy(out, name);
+    return out;
+}
+
+static bool convert_to_abs_path(int dirfd, const char* path, char* out)
+{
+    if (dirfd == AT_FDCWD || path[0] == '/') {
+        do_relocate_path(path, out);
+        return true;
+    }
+
+    char dir_path[PATH_MAX] = {0};
+    char tmp[PATH_MAX];
+    snprintf(tmp, sizeof(tmp), "/proc/self/fd/%d", dirfd);
+    ssize_t len = readlink(tmp, dir_path, sizeof(dir_path) - 1);
+    if (len <= 0) {
+        return false;
+    }
+    dir_path[len] = '\0';
+
+    char full_path[PATH_MAX];
+    snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, path);
+    do_relocate_path(full_path, out);
+    return true;
+}
+
+static size_t slash_len(const char* s)
+{
+    const char* s0 = s;
+    while (*s == '/') s++;
+    return s - s0;
+}
+
+static char* str_chrnul(const char* s, int c)
+{
+    c = (unsigned char)c;
+    if (!c) return (char*)s + strlen(s);
+
+    for (; *s && *(unsigned char*)s != c; s++);
+    return (char*)s;
+}
+
+ssize_t readlink_with_relocation(char* path, char* buf, size_t len)
+{
+    char tmp[PATH_MAX];
+    ssize_t ret = readlink(path, tmp, PATH_MAX - 1);
+    if (ret < 0) {
+        return ret;
+    }
+    tmp[ret] = '\0';
+    if (tmp[0] != '/') {
+        strncpy(buf, tmp, len);
+    }
+    else {
+        char abs[PATH_MAX];
+        do_relocate_path(tmp, abs);
+        strncpy(buf, abs, len);
+    }
+    return strlen(buf);
+}
+
+/**
+ * copy and modify from realpath of musl
+ */
+char* readpath_with_relocation(const char* restrict filename, char* restrict resolved)
+{
+    char stack[PATH_MAX + 1];
+    char output[PATH_MAX];
+    size_t p, q, l, l0, cnt = 0, nup = 0;
+    int check_dir = 0;
+
+    if (!filename) {
+        errno = EINVAL;
+        return 0;
+    }
+    l = strnlen(filename, sizeof stack);
+    if (!l) {
+        errno = ENOENT;
+        return 0;
+    }
+    if (l >= PATH_MAX) goto toolong;
+    p = sizeof stack - l - 1;
+    q = 0;
+    memcpy(stack + p, filename, l + 1);
+
+    /* Main loop. Each iteration pops the next part from stack of
+     * remaining path components and consumes any slashes that follow.
+     * If not a link, it's moved to output; if a link, contents are
+     * pushed to the stack. */
+restart:
+    for (; ; p += slash_len(stack + p)) {
+        /* If stack starts with /, the whole component is / or //
+         * and the output state must be reset. */
+        if (stack[p] == '/') {
+            check_dir = 0;
+            nup = 0;
+            q = 0;
+            output[q++] = '/';
+            p++;
+            /* Initial // is special. */
+            if (stack[p] == '/' && stack[p + 1] != '/')
+                output[q++] = '/';
+            continue;
+        }
+
+        char* z = str_chrnul(stack + p, '/');
+        l0 = l = z - (stack + p);
+
+        if (!l && !check_dir) break;
+
+        /* Skip any . component but preserve check_dir status. */
+        if (l == 1 && stack[p] == '.') {
+            p += l;
+            continue;
+        }
+
+        /* Copy next component onto output at least temporarily, to
+         * call readlink, but wait to advance output position until
+         * determining it's not a link. */
+        if (q && output[q - 1] != '/') {
+            if (!p) goto toolong;
+            stack[--p] = '/';
+            l++;
+        }
+        if (q + l >= PATH_MAX) goto toolong;
+        memcpy(output + q, stack + p, l);
+        output[q + l] = 0;
+        p += l;
+
+        int up = 0;
+        if (l0 == 2 && stack[p - 2] == '.' && stack[p - 1] == '.') {
+            up = 1;
+            /* Any non-.. path components we could cancel start
+             * after nup repetitions of the 3-byte string "../";
+             * if there are none, accumulate .. components to
+             * later apply to cwd, if needed. */
+            if (q <= 3 * nup) {
+                nup++;
+                q += l;
+                continue;
+            }
+            /* When previous components are already known to be
+             * directories, processing .. can skip readlink. */
+            if (!check_dir) goto skip_readlink;
+        }
+        ssize_t k = readlink_with_relocation(output, stack, p);
+
+        if (k == p) goto toolong;
+        if (!k) {
+            errno = ENOENT;
+            return 0;
+        }
+        if (k < 0) {
+            if (errno != EINVAL) return 0;
+        skip_readlink:
+            check_dir = 0;
+            if (up) {
+                while (q && output[q - 1] != '/') q--;
+                if (q > 1 && (q > 2 || output[0] != '/')) q--;
+                continue;
+            }
+            if (l0) q += l;
+            check_dir = stack[p];
+            continue;
+        }
+        if (++cnt == SYMLOOP_MAX) {
+            errno = ELOOP;
+            return 0;
+        }
+
+        /* If link contents end in /, strip any slashes already on
+         * stack to avoid /->// or //->/// or spurious toolong. */
+        if (stack[k - 1] == '/') while (stack[p] == '/') p++;
+        p -= k;
+        memmove(stack + p, stack, k);
+
+        /* Skip the stack advancement in case we have a new
+         * absolute base path. */
+        goto restart;
+    }
+
+    output[q] = 0;
+
+    if (output[0] != '/') {
+        if (!getcwd(stack, sizeof stack)) return 0;
+        l = strlen(stack);
+        /* Cancel any initial .. components. */
+        p = 0;
+        while (nup--) {
+            while (l > 1 && stack[l - 1] != '/') l--;
+            if (l > 1) l--;
+            p += 2;
+            if (p < q) p++;
+        }
+        if (q - p && stack[l - 1] != '/') stack[l++] = '/';
+        if (l + (q - p) + 1 >= PATH_MAX) goto toolong;
+        memmove(output + l, output + p, q - p + 1);
+        memcpy(output, stack, l);
+        q = l + q - p;
+    }
+
+    if (resolved) return memcpy(resolved, output, q + 1);
+    else return strdup(output);
+
+toolong:
+    errno = ENAMETOOLONG;
+    return 0;
+}
+
+static bool real_exists(const char* path)
+{
+    struct stat s;
+    if (lstat(path, &s) < 0) {
+        return false;
+    }
+    return !S_ISLNK(s.st_mode);
+}
+
+char* relocate_path_at(int dirfd, const char* name, char* out, bool follow_symlink)
 {
-    gpointer key, value;
-    const char *ret;
+    char tmp[PATH_MAX];
+    convert_to_abs_path(dirfd, name, tmp);
 
-    /* Only do absolute paths: quick and dirty, but should mostly be OK.  */
-    if (!base || !name || name[0] != '/') {
-        return name;
+    if (follow_symlink
+        && !skip_relocation(name)
+        && !real_exists(tmp)) {
+        char* res = readpath_with_relocation(tmp, out);
+        if (!res) {
+            strcpy(out, tmp);
+        }
+    }
+    else {
+        strcpy(out, tmp);
     }
 
+    return out;
+}
+
+char* restore_path(const char* name, char* out)
+{
+    if (name[0] != '/') {
+        goto reuse;
+    }
+
+    char buf_base[PATH_MAX];
+    strcpy(buf_base, base);
+    int len = strlen(buf_base);
+    if (len == 0 || buf_base[len - 1] != '/') {
+        strcat(buf_base, "/");
+    }
+
+    if (strstr(name, buf_base) == name) {
+        strcpy(out, name + strlen(buf_base) - 1);
+        return out;
+    }
+
+reuse:
+    strcpy(out, name);
+    return out;
+}
+
+char* resolve_with_path_env(const char* path_env, int dirfd, const char* name, char* out)
+{
+    if (!path_env || !name || !out) return NULL;
+
+    char* path_copy = strdup(path_env);
+    if (!path_copy) return NULL;
+
+    char reloc[PATH_MAX];
+    const int r = access(relocate_path_at(dirfd, name, reloc, true), F_OK);
+    if (r == 0) {
+        strncpy(out, name, PATH_MAX);
+        return out;
+    }
+
+    char* ret = NULL;
+
     qemu_mutex_lock(&lock);
 
-    /* Have we looked up this file before?  */
-    if (g_hash_table_lookup_extended(hash, name, &key, &value)) {
-        ret = value ? value : name;
-    } else {
-        char *save = g_strdup(name);
-        char *full = g_build_filename(base, name, NULL);
-
-        /* Look for the path; record the result, pass or fail.  */
-        if (access(full, F_OK) == 0) {
-            /* Exists.  */
-            g_hash_table_insert(hash, save, full);
-            ret = full;
-        } else {
-            /* Does not exist.  */
-            g_free(full);
-            g_hash_table_insert(hash, save, NULL);
-            ret = name;
+    char* dir = strtok(path_copy, ":");
+    char full_path[PATH_MAX];
+
+    while (dir) {
+        snprintf(full_path, sizeof(full_path), "%s/%s", dir, name);
+
+        const int r = access(relocate_path_at(AT_FDCWD, full_path, reloc, true), F_OK);
+        if (r == 0) {
+            strncpy(out, full_path, PATH_MAX);
+            ret = out;
+            break;
         }
+
+        dir = strtok(NULL, ":");
     }
 
     qemu_mutex_unlock(&lock);
+
+    free(path_copy);
     return ret;
 }
+
+char* resolve_abs_with_cwd(const char* path, char* out)
+{
+    if (path[0] != '/') {
+        char* cwd = g_get_current_dir();
+        char* abs_base = g_build_filename(cwd, path, NULL);
+        strcpy(out, abs_base);
+        g_free(cwd);
+        g_free(abs_base);
+        return out;
+    }
+    else {
+        strcpy(out, path);
+        return out;
+    }
+}
-- 
2.43.0

